using SnowblindModPlayer.Core.Services;

namespace SnowblindModPlayer.Infrastructure.Services;

public class ThumbnailService : IThumbnailService
{
    private const int ThumbnailWidth = 320;
    private const double AspectRatio = 16.0 / 9.0;
    private const int ThumbnailHeight = (int)(ThumbnailWidth / AspectRatio); // 180px

    public async Task<string> GenerateThumbnailAsync(string videoPath, string outputPath, TimeSpan? videoDuration = null)
    {
        try
        {
            if (string.IsNullOrEmpty(videoPath) || !File.Exists(videoPath))
            {
                throw new FileNotFoundException($"Video file not found: {videoPath}");
            }

            // Ensure output directory exists
            string outputDir = Path.GetDirectoryName(outputPath);
            if (!string.IsNullOrEmpty(outputDir))
            {
                Directory.CreateDirectory(outputDir);
            }

            // For MVP: Create a simple placeholder/gray image as thumbnail
            // In a real implementation with LibVLC, we would extract actual frame here
            // Frame time: 5% of duration, fallback to 1 second
            await CreatePlaceholderThumbnailAsync(outputPath);
            
            System.Diagnostics.Debug.WriteLine($"Thumbnail generated: {outputPath}");
            return outputPath;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Thumbnail generation failed: {ex.Message}");
            // Return path anyway - import continues without thumbnail
            return outputPath;
        }
    }

    /// <summary>
    /// Creates a simple gray placeholder thumbnail (320x180) as JPG.
    /// In future: extract actual frame at 5% video duration using LibVLC.
    /// </summary>
    private async Task CreatePlaceholderThumbnailAsync(string outputPath)
    {
        // Create a small valid JPG (1x1) as placeholder to avoid WPF decode errors.
        // This will be replaced later by real VLC snapshot thumbnails.
        await Task.Run(() =>
        {
            Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);

            // Minimal 1x1 JPEG (JFIF) bytes.
            // Source: generated once for placeholder usage.
            var jpg = new byte[]
            {
                0xFF,0xD8,0xFF,0xE0,0x00,0x10,0x4A,0x46,0x49,0x46,0x00,0x01,0x01,0x01,0x00,0x48,0x00,0x48,0x00,0x00,
                0xFF,0xDB,0x00,0x43,0x00,
                0x08,0x06,0x06,0x07,0x06,0x05,0x08,0x07,0x07,0x07,0x09,0x09,0x08,0x0A,0x0C,0x14,0x0D,0x0C,0x0B,0x0B,0x0C,0x19,0x12,0x13,0x0F,0x14,0x1D,0x1A,0x1F,0x1E,0x1D,0x1A,0x1C,0x1C,0x20,0x24,0x2E,0x27,0x20,0x22,0x2C,0x23,0x1C,0x1C,0x28,0x37,0x29,0x2C,0x30,0x31,0x34,0x34,0x34,0x1F,0x27,0x39,0x3D,0x38,0x32,0x3C,0x2E,0x33,0x34,0x32,
                0xFF,0xC0,0x00,0x11,0x08,0x00,0x01,0x00,0x01,0x03,0x01,0x11,0x00,0x02,0x11,0x01,0x03,0x11,0x01,
                0xFF,0xC4,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0xFF,0xC4,0x00,0x14,0x10,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0xFF,0xDA,0x00,0x0C,0x03,0x01,0x00,0x02,0x11,0x03,0x11,0x00,0x3F,0x00,
                0x00,
                0xFF,0xD9
            };

            File.WriteAllBytes(outputPath, jpg);
        });
    }
}
